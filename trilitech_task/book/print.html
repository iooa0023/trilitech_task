<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js coal">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>trilitech_task</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="././mdbook-admonish.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "coal";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('coal')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">Tutorials</li><li class="chapter-item "><a href="tutorials/overview-1.0.html"><strong aria-hidden="true">1.</strong> Creating a Simple dApp on Tezos</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tutorials/page-1.0.html"><strong aria-hidden="true">1.1.</strong> Pre-requisites</a></li><li class="chapter-item "><a href="tutorials/page-1.1.html"><strong aria-hidden="true">1.2.</strong> Setting up the dapp</a></li><li class="chapter-item "><a href="tutorials/page-1.2.html"><strong aria-hidden="true">1.3.</strong> Wallet and user’s tokens</a></li><li class="chapter-item "><a href="tutorials/page-1.3.html"><strong aria-hidden="true">1.4.</strong> Swapping tokens</a></li><li class="chapter-item "><a href="tutorials/page-1.4.html"><strong aria-hidden="true">1.5.</strong> Adding and removing liquidity</a></li><li class="chapter-item "><a href="tutorials/page-1.5.html"><strong aria-hidden="true">1.6.</strong> Conclusion</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">trilitech_task</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="creating-a-simple-dapp-on-tezos"><a class="header" href="#creating-a-simple-dapp-on-tezos"><img src='images/coin.png' style="float: right; width: 75px; height: 75px;">Creating a Simple dApp on Tezos</a></h1>
<p>In this tutorial, you will discover how to configure and establish a decentralized web application on Tezos. Together, we will fabricate an interface for the Liquidity Baking smart contract that will enable us to engage with this DEX and execute various tasks, such as exchanging tokens or delivering liquidity. Concurrently, you will be familiarized with fundamental concepts involved in creating a decentralized application, not only generally, but also particularly on Tezos.</p>
<p>Since the dapp will be created using <a href="https://www.typescriptlang.org/">TypeScript</a>, a comprehensive understanding of this programming language is essential. To develop the application, we will employ the <a href="https://svelte.dev/">Svelte</a> framework, which is fairly intuitive to use and I will provide explanations throughout the process.</p>
<p>Like 99% of the dapps in the ecosystem, this dapp will depend on <a href="https://tezostaquito.io/">Taquito</a>, a TypeScript library that guarantees a superior developer experience when interacting with the Tezos blockchain.</p>
<h3 id="the-liquidity-baking-contract"><a class="header" href="#the-liquidity-baking-contract">The Liquidity Baking contract</a></h3>
<p>Tezos boasts a remarkable contract that’s exclusively designed for decentralized exchange (DEX), called the Liquidity Baking contract. This DEX manages only three tokens: XTZ (the native token of Tezos), tzBTC (a wrapped token for Bitcoin on Tezos), and SIRS (the token that denotes an equal liquidity amount in XTZ and tzBTC supplied to the contract).</p>
<p>This contract holds a unique attribute, that is, each time a new block is baked on Tezos, 2.5 XTZ are injected into the contract. Users are anticipated to bring in tzBTC to maintain the DEX liquidity balance and the SIRS price stability.</p>
<p>Moreover, the contract is entirely public, enabling anyone with a Tezos wallet to interact with it for exchanging XTZ for tzBTC and vice-versa, adding or removing liquidity. And this is what we’ll be accomplishing together in this tutorial.</p>
<h3 id="what-are-we-going-to-build"><a class="header" href="#what-are-we-going-to-build">What are we going to build?</a></h3>
<p>In this tutorial, we will build a dapp interface that interacts with the LB contract to swap tokens, add liquidity and remove it.</p>
<div id="admonition-the-dapp-will-handle-different-actions" class="admonition tip">
<div class="admonition-title">
<p>The dapp will handle different actions</p>
<p><a class="admonition-anchor-link" href="tutorials/overview-1.0.html#admonition-the-dapp-will-handle-different-actions"></a></p>
</div>
<div>
<ul>
<li>Displaying users’ information like their XTZ, tzBTC, and SIRS balance and update them after each transaction.</li>
<li>Connecting and disconnecting the users’ wallet.</li>
<li>Displaying wallet information like its connection status and the network it’s connected to.</li>
<li>Displaying different interfaces to swap tokens, add and remove liquidity.</li>
<li>Allowing users to swap XTZ for tzBTC and tzBTC for XTZ.</li>
<li>Allowing users to add liquidity by providing XTZ and tzBTC and getting SIRS in exchange.</li>
<li>Allowing users to remove liquidity, i.e. to redeem SIRS tokens and get XTZ and tzBTC tokens in exchange.</li>
</ul>
</div>
</div>
<p>Take a look at this flow chart to visual the flow of actions in dapp:</p>
<pre><code>  +-----------------------+
  |                       |
  |    Main Dashboard  	  |
  |                       |
  +-----------------------+
              |
              | Wallet Connection
              |
  +-----------------------+
  |                       |
  |   Wallet Information  |
  |                       |
  +-----------------------+
              |
              | Token Swap or Liquidity Provision/Removal
              |
  +-----------------------+
  |                       |
  |   Tezos Blockchain    |
  |                       |
  +-----------------------+
              |
              | Transaction Execution
              |
  +-----------------------+
  |                       |
  |    Balance Update     |
  |                       |
  +-----------------------+
              |
              | Wallet Disconnection
              |
  +-----------------------+
  |                       |
  |   End of Transaction  |
  |                       |
  +-----------------------+
</code></pre>
<div id="admonition-repository" class="admonition info">
<div class="admonition-title">
<p>Repository</p>
<p><a class="admonition-anchor-link" href="tutorials/overview-1.0.html#admonition-repository"></a></p>
</div>
<div>
<p>Before we dive into creating the decentralized web application, the GitHub repository for this project is available for you to access, if you want to play around. You can find it <a href="https://github.com/claudebarde/tezos-dev-portal-tutorial">here</a>. With that said, let’s move forward and start building our application step-by-step.</p>
</div>
</div>
<p><a href="tutorials//tutorials/page-1.1.html">Next Page →</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-requisites"><a class="header" href="#pre-requisites">Pre-requisites</a></h1>
<h3 id="what-tools-are-we-going-to-use"><a class="header" href="#what-tools-are-we-going-to-use">What tools are we going to use?</a></h3>
<p>Before diving into building our decentralized application, it’s essential to have a solid understanding of the tools we’ll be using to develop it. As this app is a web application, we’ll be utilizing the following tools:</p>
<ol>
<li>
<p><a href="https://svelte.dev/">Svelte</a>: A JavaScript framework that enables us to build performant web applications with ease.</p>
</li>
<li>
<p><a href="https://www.typescriptlang.org/">TypeScript</a>: A superset of JavaScript that makes our code more reliable and expressive.</p>
</li>
<li>
<p><a href="https://sass-lang.com/">Sass</a>: A CSS preprocessor that enables us to write maintainable and scalable CSS code.</p>
</li>
<li>
<p><a href="https://vitejs.dev/">Vite</a>: A modern build tool that is used for fast and efficient application bundling.</p>
</li>
<li>
<p><a href="https://tezostaquito.io/">Taquito</a>: A TypeScript library that provides a better developer experience for interacting with the Tezos blockchain.</p>
</li>
<li>
<p><a href="https://docs.walletbeacon.io/">Beacon</a>: A wrapper library provided by Taquito to use a Tezos wallet.</p>
</li>
</ol>
<p>Having a good grasp of these tools is crucial to developing a successful decentralized application on Tezos.</p>
<p><a href="tutorials//tutorials/overview-1.0.html">← Previous Page</a></p>
<p><a href="tutorials//tutorials/page-1.1.html">Next Page →</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-the-dapp"><a class="header" href="#setting-up-the-dapp">Setting up the dapp</a></h1>
<p>As we are building a web app with the Svelte framework, the steps to set up the project will be very similar to the ones you would follow to set up any other web app.</p>
<p>In this tutorial, we will make a Svelte SPA, so we won’t need SvelteKit, which will also make our life easier.</p>
<ol>
<li>The first thing to do is to install Svelte with TypeScript and Vite:</li>
</ol>
<pre><code>npm create vite@latest app -- --template svelte-ts
cd lb-dex
npm install
</code></pre>
<ol start="2">
<li>Next, we will install all the dependencies we need for the dapp:</li>
</ol>
<pre><code>npm install --save-dev sass
npm install @taquito/taquito @taquito/beacon-wallet
</code></pre>
<div id="admonition-info" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.1.html#admonition-info"></a></p>
</div>
<div>
<p>Sass is a development-only dependency, <code>@taquito/taquito</code> is the NPM package for the Taquito library and <code>@taquito/beacon-wallet</code> is the NPM package that contains Beacon with some little configuration to make it easier to plug into Taquito.</p>
</div>
</div>
<ol start="3">
<li>There are a couple of other libraries we need to install:</li>
</ol>
<pre><code>npm install --save-dev buffer events vite-compatible-readable-stream
</code></pre>
<p>These libraries are required to be able to run Beacon in a Svelte app. We will see down below how to use them.
Once everything has been installed, we have to set up the right configuration.</p>
<ol start="4">
<li>In your app folder, you will see the <code>vite.config.js</code> file, it’s the file that contains the configuration that Vite needs to run and bundle your app. Make the following changes:</li>
</ol>
<pre><code class="language-JS">import { defineConfig, mergeConfig } from &quot;vite&quot;;
import path from &quot;path&quot;;
import { svelte } from &quot;@sveltejs/vite-plugin-svelte&quot;;

export default ({ command }) =&gt; {
  const isBuild = command === &quot;build&quot;;
  
  return defineConfig({
    plugins: [svelte()],
    define: {
      global: {}
    },
    build: {
      target: &quot;esnext&quot;,
      commonjsOptions: {
        transformMixedEsModules: true
      }
    },
    server: {
      port: 4000
    },
    resolve: {
      alias: {
        &quot;@airgap/beacon-sdk&quot;: path.resolve(
          path.resolve(),
          `./node_modules/@airgap/beacon-sdk/dist/${
            isBuild ? &quot;esm&quot; : &quot;cjs&quot;
          }/index.js`
        ),
        // polyfills
        &quot;readable-stream&quot;: &quot;vite-compatible-readable-stream&quot;,
        stream: &quot;vite-compatible-readable-stream&quot;
      }
    }
  });
};
</code></pre>
<p>Here are a few changes we made to the template configuration given by Vite:</p>
<ul>
<li>We set <code>global</code> to <code>{}</code> and we will later provide the global object in our HTML file.</li>
<li>We provide a path to the Beacon SDK.</li>
<li>We provide polyfills for <code>readable-stream</code> and <code>stream</code>.</li>
</ul>
<ol start="5">
<li>Once these changes have been done, there is a last step to finish setting up the project: we have to update the HTML file where the JavaScript code will be injected.</li>
</ol>
<p>Inside the <code>index.html</code> file, you should have the following:</p>
<pre><code class="language-HTML">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;script&gt;
      const global = globalThis;
    &lt;/script&gt;
    &lt;script type=&quot;module&quot;&gt;
      import { Buffer } from &quot;buffer&quot;;
      window.Buffer = Buffer;
    &lt;/script&gt;
    &lt;title&gt;Liquidity Baking DEX&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script type=&quot;module&quot; src=&quot;/src/main.ts&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>In the first script tag, we set the global variable to globalThis. </li>
<li>In the second script tag with a module type, we import Buffer from the buffer library and add it to the window global object.</li>
</ul>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.1.html#admonition-note"></a></p>
</div>
<div>
<p>This configuration is required to run the Beacon SDK with a Vite app. Taquito works completely out of the box and doesn’t require any settings.</p>
</div>
</div>
<ol start="6">
<li>Once we updated the configuration in the <code>vite.config.js</code> file and in the <code>index.html</code> file, our project is successfully set up! </li>
</ol>
<p>Run the following in your terminal at the root of the project to check that everything works properly:</p>
<pre><code>npm run dev
</code></pre>
<div id="admonition-expected-output" class="admonition success">
<div class="admonition-title">
<p>Expected Output</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.1.html#admonition-expected-output"></a></p>
</div>
<div>
<p>VITE v4.2.1  ready in 680 ms</p>
<p>➜  Local:   http://localhost:4000/</p>
<p>➜  Network: use –host to expose</p>
<p>➜  press h to show help</p>
</div>
</div>
Congratulations! The dapp should be running on http://localhost:4000. You can also see the activity log on the application in your terminal.
<h3 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h3>
<p>The entrypoint of every Svelte app is a file called <code>App.svelte</code>, this is where you will import all your components to be bundled together into your final app. If you haven’t done so, create the folders and files n eccessary for this tutorial so the file structure of our project looks like this:</p>
<pre><code>├── src/
│   ├── assets/
│   │   └── svelte.png
│   ├── lib/
│   │   ├── AddLiquidityView.svelte
│   │   ├── Interface.svelte
│   │   ├── RemoveLiquidity.svelte
│   │   ├── Sidebar.svelte
│   │   ├── SirsStats.svelte
│   │   ├── SwapView.svelte
│   │   ├── Toast.svelte
│   │   ├── UserInput.svelte
│   │   ├── UserStats.svelte
│   │   └── Wallet.svelte
│   ├── styles/
│   │   ├── index.scss
│   │   └── settings.scss
│   ├── App.svelte
│   ├── config.ts
│   ├── lbUtils.ts
│   ├── main.ts
│   ├── store.ts
│   ├── types.ts
│   └── utils.ts
├── index.html
├── svelte.config.js
├── tsconfig.json
└── vite.config.js
</code></pre>
<div id="admonition-what-are-these" class="admonition tip">
<div class="admonition-title">
<p>What are these?</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.1.html#admonition-what-are-these"></a></p>
</div>
<div>
<ul>
<li><strong>assets</strong>: contains the favicon (here, this is the default Svelte favicon, but you can choose another one)</li>
<li><strong>lib</strong>: contains the different components that will make up our interface, here is what each does:
<ul>
<li><code>SwapView.svelte</code>: the interface to swap XTZ and tzBTC tokens</li>
<li><code>AddLiquidityView.svelte</code>: the interface to add liquidity to the LB DEX</li>
<li><code>RemoveLiquidity.svelte</code>: the interface to remove liquidity from the LB DEX</li>
<li><code>Interface.svelte</code>: the higher-order component to hold the different views to interact with the LB DEX</li>
<li><code>Sidebar.svelte</code>: the component to navigate between the different interfaces and to connect or disconnect the wallet</li>
<li><code>SirsStats.svelte</code>: the component to display the amount of XTZ, tzBTC, and SIRS present in the contract</li>
<li><code>Toast.svelte</code>: a simple component to display the progression of the transactions and other messages when interacting with the contract</li>
<li><code>UserInput.svelte</code>: a utility component to make it easier to interact and control input fields</li>
<li><code>UserStats.svelte</code>: the component to display the user’s balance in XTZ, tzBTC, and SIRS</li>
<li><code>Wallet.svelte</code>: the component to manage wallet interactions</li>
</ul>
</li>
<li><strong>styles</strong>: contains the SASS files to style different elements of our interface</li>
<li><strong>App.svelte</strong>: the entrypoint of the application</li>
<li><strong>config.ts</strong>: different immutable values needed for the application and saved in a separate file for convenience</li>
<li><strong>lbUtils.ts</strong>: different methods to calculate values needed to interact with the Liquidity Baking contract</li>
<li><strong>main.ts</strong>: this is where the JavaScript for the app is bundled before being injected into the HTML file</li>
<li><strong>store.ts</strong>: a file with a <a href="https://svelte.dev/tutorial/writable-stores">Svelte store</a> to handle the dapp state</li>
<li><strong>types.ts</strong>: custom TypeScript types</li>
<li><strong>utils.ts</strong>: different utility methods</li>
</ul>
</div>
</div>
1. The first thing to do is to import our styles into the main.ts file:
<pre><code class="language-TS">import App from './App.svelte'
import &quot;./styles/index.scss&quot;;

const app = new App({
 target: document.body
});
export default app;
</code></pre>
<div id="admonition-note-1" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.1.html#admonition-note-1"></a></p>
</div>
<div>
<p>We recommend targetting the <code>body</code> tag to inject the HTML produced by JavaScript instead of a <code>div</code> inside the <code>body</code>.</p>
</div>
</div>
<ol start="2">
<li>Check the <code>App.svelte</code> file looks something like this:</li>
</ol>
<pre><code class="language-TS">&lt;script lang=&quot;ts&quot;&gt;
  ... your TypeScript code
&lt;/script&gt;

&lt;style lang=&quot;scss&quot;&gt;
   ... your SASS code
&lt;/style&gt;

... your HTML code
</code></pre>
<p>Svelte components are fully contained, which means that the style that you apply inside a component doesn’t leak into the other components of your app. The style that we want to share among different components will be written in the <code>index.scss</code> file.</p>
<p>There is a <code>script</code> tag with a lang attribute set to <code>ts</code> for TypeScript, a style tag with a <code>lang</code> attribute set to <code>scss</code> for SASS and the rest of the code in the file will be interpreted as HTML.</p>
<h3 id="configuring-the-dapp"><a class="header" href="#configuring-the-dapp">Configuring the dapp</a></h3>
<ol>
<li>Let’s set up things differently in our <code>App.svelte</code> file.</li>
</ol>
<p>The HTML part is just going to put all the higher-order components together. Replace the HTML with the following:</p>
<pre><code class="language-HTML">&lt;main&gt;
  &lt;Toast /&gt;
  {#if $store.Tezos &amp;&amp; $store.dexInfo}
    &lt;Sidebar /&gt;
    &lt;Interface /&gt;
  {:else}
    &lt;div&gt;Loading&lt;/div&gt;
  {/if}
&lt;/main&gt;
</code></pre>
<p>The interface will change after different elements are available to the dapp, mostly, the data about the liquidity pools from the liquidity baking contract.</p>
<ol start="2">
<li>Replace the SASS part of the file with the following:</li>
</ol>
<pre><code class="language-CSS">@import &quot;./styles/settings.scss&quot;;

main {
 display: grid;
 grid-template-columns: 250px 1fr;
 gap: $padding;
 padding: $padding;
 height: calc(100% - (#{$padding} * 2));
}
@media screen and (max-height: 700px) {
 main {
   padding: 0px;
   height: 100%;
 }
}
</code></pre>
<ol start="3">
<li>For TypeScript part import the libraries and components we need inside the <code>&lt;script&gt;</code> tag:</li>
</ol>
<pre><code class="language-TS">import { onMount } from &quot;svelte&quot;;
import { TezosToolkit } from &quot;@taquito/taquito&quot;;
import store from &quot;./store&quot;;
import { rpcUrl, dexAddress } from &quot;./config&quot;;
import Sidebar from &quot;./lib/Sidebar.svelte&quot;;
import Interface from &quot;./lib/Interface.svelte&quot;;
import Toast from &quot;./lib/Toast.svelte&quot;;
import type { Storage } from &quot;./types&quot;;
import { fetchExchangeRates } from &quot;./utils&quot;;
</code></pre>
<div id="admonition-what-are-these-1" class="admonition tip">
<div class="admonition-title">
<p>What are these?</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.1.html#admonition-what-are-these-1"></a></p>
</div>
<div>
<ul>
<li><code>onMount</code> is a method exported by Svelte that will run some code when the component mounts (more on that below)</li>
<li><code>TezosToolkit</code> is the class that gives you access to all the features of Taquito</li>
<li><code>store</code> is a Svelte feature to manage the state of the dapp</li>
<li>From the <code>config.ts</code> file, we import <code>rpcUrl</code> (the URL of the Tezos RPC node) and <code>dexAddress</code>, the address of the Liquidity Baking contract</li>
<li><code>Storage</code> is a custom type that represents the signature type of the LB DEX storage</li>
<li><code>fetchExchangeRates</code> is a function to fetch the exchange rates of XTZ and tzBTC (more on that below)</li>
</ul>
</div>
</div>
<ol start="4">
<li>Additionally include the <code>onMount</code> to set up the state of the dapp also inside the <code>&lt;script&gt;</code> tag after the imprted librarires and components:</li>
</ol>
<pre><code class="language-TS">onMount(async () =&gt; {
  const Tezos = new TezosToolkit(rpcUrl);
  store.updateTezos(Tezos);
  const contract = await Tezos.wallet.at(dexAddress);
  const storage: Storage | undefined = await contract.storage();

  if (storage) {
    store.updateDexInfo({ ...storage });
  }
  // fetches XTZ and tzBTC prices
  const res = await fetchExchangeRates();
  if (res) {
    store.updateExchangeRates([
      { token: &quot;XTZ&quot;, exchangeRate: res.xtzPrice },
      { token: &quot;tzBTC&quot;, exchangeRate: res.tzbtcPrice }
    ]);
  } else {
    store.updateExchangeRates([
      { token: &quot;XTZ&quot;, exchangeRate: null },
      { token: &quot;tzBTC&quot;, exchangeRate: null }
    ]);
  }
});
</code></pre>
<p>The first thing to do is to create an instance of the <code>TezosToolkit</code> by passing the URL of the RPC node we want to interact with. In general, you want to have a single instance of the <code>TezosToolkit</code> in order to keep the same configuration across all your app components, this is why we save it in the store with the <code>updateTezos</code> method.</p>
<p>After that, we want to fetch the storage of the LB DEX to get the amounts of XTZ, tzBTC, and SIRS in the contract. We create a <code>ContractAbstraction</code>, an instance provided by Taquito with different properties and methods that are useful to work with Tezos smart contracts. From the <code>ContractAbstraction</code>, we can call the <code>storage</code> method that returns a JavaScript object that represents the storage of the given contract. We then pass the storage to the <code>updateDexInfo</code> method present on the <code>store</code> to update this data and display them to the user.</p>
<ol start="5">
<li>To finish this part of the tutorial, we need to fetch the exchange rates for XTZ and tzBTC to make the conversions required by this kind of app. </li>
</ol>
<p>Inside the <code>utils.ts</code> file, paste the folllowing function:</p>
<pre><code class="language-TS">export const fetchExchangeRates = async (): Promise&lt;{
  tzbtcPrice: number;
  xtzPrice: number;
} | null&gt; =&gt; {
  const query = `
      query {
        overview { xtzUsdQuote },
        token(id: &quot;KT1PWx2mnDueood7fEmfbBDKx1D9BAnnXitn&quot;) { price }
      }
    `;
  const res = await fetch(`https://analytics-api.quipuswap.com/graphql`, {
    method: &quot;POST&quot;,
    headers: {
      &quot;Content-Type&quot;: &quot;application/json&quot;
    },
    body: JSON.stringify({
      query
    })
  });
  if (res.status === 200) {
    const resData = await res.json();
    let xtzPrice = resData?.data?.overview?.xtzUsdQuote;
    let tzbtcPrice = resData?.data?.token?.price;
    // validates the 2 values
    if (xtzPrice &amp;&amp; tzbtcPrice) {
      xtzPrice = +xtzPrice;
      tzbtcPrice = +tzbtcPrice;
      if (!isNaN(xtzPrice) &amp;&amp; !isNaN(tzbtcPrice)) {
        // tzBTC price is given in XTZ by the API
        tzbtcPrice = tzbtcPrice * xtzPrice;
        return { tzbtcPrice, xtzPrice };
      }
    } else {
      return null;
    }
  } else {
    return null;
  }
};
</code></pre>
<p>The exchange rates required for the DEX are obtained by utilizing the <a href="https://analytics-api.quipuswap.com/graphql">QuipuSwap GraphQL API</a>. Upon receiving the exchange rates, we parse the response to validate the prices offered for XTZ and tzBTC. Following successful validation, the function returns the confirmed prices which can then be stored. The exchange rates are instrumental in calculating the total value locked in the contract, denominated in USD or other fiat currencies.</p>
<p><a href="tutorials//tutorials/page-1.0.html">← Previous Page</a></p>
<p><a href="tutorials//tutorials/page-1.2.html">Next Page →</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet-and-users-tokens"><a class="header" href="#wallet-and-users-tokens">Wallet and user’s tokens</a></h1>
<h3 id="setting-up-the-wallet"><a class="header" href="#setting-up-the-wallet">Setting up the wallet</a></h3>
<p>The wallet is a key element of your dapp, without it, the users won’t be able to interact with the Tezos blockchain, which defeats your purpose. There are multiple considerations to take into account when you are setting up the wallet that we will explain below.</p>
<ol>
<li>Make sure the <code>Wallet.svelte</code> file looks something like this:</li>
</ol>
<pre><code class="language-TS">&lt;script lang=&quot;ts&quot;&gt;
  ... your TypeScript code
&lt;/script&gt;

&lt;style lang=&quot;scss&quot;&gt;
   ... your SASS code
&lt;/style&gt;

... your HTML code
</code></pre>
<p>Import the following libraries and components inside the <code>&lt;script&gt;</code> tag:</p>
<pre><code class="language-TS">  import { onMount } from &quot;svelte&quot;;
  import { BeaconWallet } from &quot;@taquito/beacon-wallet&quot;;
  import store, { type TezosAccountAddress } from &quot;../store&quot;;
  import { rpcUrl, network } from &quot;../config&quot;;
  import { shortenHash, fetchBalances } from &quot;../utils&quot;;
</code></pre>
<p>Below this, also declare these variables:</p>
<pre><code class="language-TS"> let connectedNetwork = &quot;&quot;;
 let walletIcon = &quot;&quot;;
 let walletName = &quot;&quot;;
</code></pre>
<div id="admonition-what-are-these" class="admonition tip">
<div class="admonition-title">
<p>What are these?</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.2.html#admonition-what-are-these"></a></p>
</div>
<div>
<ul>
<li><code>connectedNetwork</code>: Used to store the name or identifier of a network that a user is currently connected to.</li>
<li><code>walletIcon</code>: Used to store the file path or URL of an icon or logo that represents a user’s wallet.</li>
<li><code>walletName</code>: Used to store the name or identifier of a wallet that a user is currently using.</li>
</ul>
</div>
</div>
<p>Also don’t forget to include the <code>onMount</code> function we created previous and the end of the <code>&lt;script&gt;</code>.</p>
<ol start="2">
<li>We want to isolate the wallet and its different interactions and values in the same component, called <code>Wallet.svelte</code> in our example. When using the Beacon SDK, it is crucial to keep a single instance of Beacon running in order to prevent bugs.</li>
</ol>
<p>Add the following inside the <code>&lt;script&gt;</code> tag:</p>
<pre><code class="language-TS">onMount(async () =&gt; {
    const wallet = new BeaconWallet({
      name: &quot;Tezos dev portal dapp tutorial&quot;,
      preferredNetwork: network
    });
    store.updateWallet(wallet);
    const activeAccount = await wallet.client.getActiveAccount();
    if (activeAccount) {
      const userAddress = (await wallet.getPKH()) as TezosAccountAddress;
      store.updateUserAddress(userAddress);
      $store.Tezos.setWalletProvider(wallet);
      await getWalletInfo(wallet);
      // fetches user's XTZ, tzBTC and SIRS balances
      const res = await fetchBalances($store.Tezos, userAddress);
      if (res) {
        store.updateUserBalance(&quot;XTZ&quot;, res.xtzBalance);
        store.updateUserBalance(&quot;tzBTC&quot;, res.tzbtcBalance);
        store.updateUserBalance(&quot;SIRS&quot;, res.sirsBalance);
      } else {
        store.updateUserBalance(&quot;XTZ&quot;, null);
        store.updateUserBalance(&quot;tzBTC&quot;, null);
        store.updateUserBalance(&quot;SIRS&quot;, null);
      }
    }
  });
</code></pre>
<p>We create the instance of the <code>BeaconWallet</code> by providing a name for the dapp (it can be whatever you want) that will be displayed in the wallet UI and the network you want to connect to (imported from the config file). The instance of the wallet is then saved in the store.</p>
<p>Now, you want to check if the user connected a wallet before. Beacon will keep track of live connections in the local storage, this is how your users can navigate to your dapp and have their wallet connected automagically!</p>
<p>The <code>BeaconWallet</code> instance provides a <code>client</code> property with different methods, the one you need here is <code>getActiveAccount()</code>, which will retrieve any live connection stored in the local storage. If there is a live connection, you can fetch the user’s address and save it into the store, update the store with the user’s address before setting up the wallet as the signer with <code>$store.Tezos.setWalletProvider(wallet)</code>, get the information you need about the wallet (mainly, the name of the wallet) with the getWalletInfo() function and then, fetch the balances for the address that is connected with the fetchBalances() function described earlier. </p>
<p>Once the balances are fetched, they are saved into the store to be displayed in the interface.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.2.html#admonition-note"></a></p>
</div>
<div>
<p>TezosAccountAddress is a custom type I like to use to validate Tezos addresses for implicit accounts: <code>type TezosAccountAddress = tz${&quot;1&quot; | &quot;2&quot; | &quot;3&quot;}${string}</code>, TypeScript will raise a warning if you try to use a string that doesn’t match this pattern.</p>
</div>
</div>
<h3 id="connecting-the-wallet"><a class="header" href="#connecting-the-wallet">Connecting the wallet</a></h3>
<p>Taquito and Beacon working in unison makes it very easy to connect the wallet. </p>
<ol>
<li>By adding a few lines of code so it looks like this:</li>
</ol>
<pre><code class="language-TS">const connectWallet = async () =&gt; {
  if (!$store.wallet) {
    const wallet = new BeaconWallet({
      name: &quot;Tezos dev portal dapp tutorial&quot;,
      preferredNetwork: network
    });
    store.updateWallet(wallet);
  }
  await $store.wallet.requestPermissions({
    network: { type: network, rpcUrl }
  });
  const userAddress = (await $store.wallet.getPKH()) as TezosAccountAddress;
  store.updateUserAddress(userAddress);
  $store.Tezos.setWalletProvider($store.wallet);
  // finds account info
  await getWalletInfo($store.wallet);
  // fetches user's XTZ, tzBTC and SIRS balances
  const res = await fetchBalances($store.Tezos, userAddress);
  if (res) {
    store.updateUserBalance(&quot;XTZ&quot;, res.xtzBalance);
    store.updateUserBalance(&quot;tzBTC&quot;, res.tzbtcBalance);
    store.updateUserBalance(&quot;SIRS&quot;, res.sirsBalance);
  } else {
    store.updateUserBalance(&quot;XTZ&quot;, null);
    store.updateUserBalance(&quot;tzBTC&quot;, null);
    store.updateUserBalance(&quot;SIRS&quot;, null);
  }
};
</code></pre>
<p>The connection will be handled in a specific function called connectWallet. If the store doesn’t hold an instance of the <code>BeaconWallet</code> (if the dapp didn’t detect any live connection on mount), you create that instance and save it in the store.</p>
<p>Next, you ask the user to select a wallet with the <code>requestPermissions()</code> method present on the instance of the BeaconWallet. The parameter is an object where you indicate the network you want to connect to as well as the URL of the Tezos RPC node you will interact with.</p>
<p>After the user selects a wallet to use with our dapp, you get their address with the <code>getPKH()</code> method on the <code>BeaconWallet</code> instance, you update the signer in the <code>TezosToolkit</code> instance by passing the wallet instance to <code>setWalletProvider()</code>, you get the information you need from the wallet and you fetch the user’s balances.</p>
<div id="admonition-default" class="admonition success">
<div>
<p>Now, the wallet is connected and the user is shown their different balances, as well as a connection status in the sidebar!</p>
</div>
</div>
<div id="admonition-important" class="admonition warning">
<div class="admonition-title">
<p>IMPORTANT</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.2.html#admonition-important"></a></p>
</div>
<div>
<p>No matter how you decide to design your dapp, it is crucial to maintain only one instance of the BeaconWallet, and it is strongly advised to do the same with the instance of the TezosToolkit. If you create multiple instances, it can lead to complications with the state of your application and cause issues with Taquito overall.</p>
</div>
</div>
<h3 id="disconnecting-the-wallet"><a class="header" href="#disconnecting-the-wallet">Disconnecting the wallet</a></h3>
<p>Disconnecting the wallet is as important as connecting it. A lot of users have multiple wallets and addresses within the same wallet that they want to use to interact with your dapp.</p>
<p>Therefore adding the following code inside the <code>&lt;script&gt;</code> tag after our <code>connectWallet</code> funcctionlity will ensure this making it easier:</p>
<pre><code class="language-TS">const disconnectWallet = async () =&gt; {
  $store.wallet.client.clearActiveAccount();
  store.updateWallet(undefined);
  store.updateUserAddress(undefined);
  connectedNetwork = &quot;&quot;;
  walletIcon = &quot;&quot;;
};
</code></pre>
<div id="admonition-what-are-these-1" class="admonition tip">
<div class="admonition-title">
<p>What are these?</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.2.html#admonition-what-are-these-1"></a></p>
</div>
<div>
<p>There are different steps to disconnect the wallet and reset the state of the dapp:</p>
<ul>
<li><code>$store.wallet.client.clearActiveAccount()</code>: Terminates the current connection to Beacon.</li>
<li><code>store.updateWallet(undefined)</code>: Removes the wallet from the state in order to trigger a reload of the interface.</li>
<li><code>store.updateUserAddress(undefined)</code>: Removes the current user’s address from the state to update the UI.</li>
<li><code>connectedNetwork = &quot;&quot;; walletIcon = &quot;&quot;</code>: needed to reset the state of the dapp and present an interface where no wallet is connected.</li>
</ul>
<p>The call to <code>clearActiveAccount()</code> on the wallet instance is the only thing that you will do in whatever dapp you are building, it will remove all the data in the local storage and when your user revisits your dapp, they won’t be automatically connected with their wallet.</p>
</div>
</div>
<div id="admonition-design-considerations" class="admonition example">
<div class="admonition-title">
<p>Design considerations</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.2.html#admonition-design-considerations"></a></p>
</div>
<div>
<ul>
<li>
<p>Avoid prompting users to connect their wallet immediately after the dapp loads. Provide information about your dapp and a clear, prominently displayed button for users to manually connect their wallet.</p>
</li>
<li>
<p>Ensure the button to connect a wallet stands out in your interface and is easy to locate.</p>
</li>
<li>
<p>Keep the button in a predictable position, such as the top-left or top-right of the UI, to avoid user confusion.</p>
</li>
<li>
<p>Use clear and concise language for the button text, such as “Connect.” Display the wallet status, network, and balance to keep users informed.</p>
</li>
<li>
<p>Enable/disable interactions that depend on a connected wallet to prevent user confusion.</p>
</li>
</ul>
</div>
</div>
<h3 id="fetching-users-balances"><a class="header" href="#fetching-users-balances">Fetching user’s balances</a></h3>
<p>Fetching and displaying user balances is crucial in a dapp, and should not be overlooked. To ensure balances are shown and updated correctly, create a function in the utils.ts file and import it where necessary. In order to fetch balances, we use Taquito for XTZ and the <a href="https://api.tzkt.io/">TzKT API</a> for tzBTC and SIRS. TzKT is a useful tool for building more complex applications on Tezos.</p>
<ol>
<li>Import the following to the top the <code>utils.ts</code>:</li>
</ol>
<pre><code class="language-TS">import BigNumber from &quot;bignumber.js&quot;;
import type { TezosToolkit } from &quot;@taquito/taquito&quot;;
import type { token } from &quot;./types&quot;;
import type { TezosAccountAddress } from &quot;./store&quot;;
import { tzbtcAddress, sirsAddress } from &quot;./config&quot;;
</code></pre>
<ol start="2">
<li>Then add the function <code>fetchBalances</code>:</li>
</ol>
<pre><code class="language-TS">export const fetchBalances = async (
  Tezos: TezosToolkit,
  userAddress: TezosAccountAddress
): Promise&lt;{
  xtzBalance: number;
  tzbtcBalance: number;
  sirsBalance: number;
} | null&gt; =&gt; {
  try {
    // the code will be here
  } catch (error) {
    console.error(error);
    return null;
  }
}
</code></pre>
<p>The <code>fetchBalances</code> function will take 2 parameters: An instance of the <code>TezosToolkit</code> to fetch the user’s XTZ balance and the user’s address to retrieve the balances that match the address. It will return an object with 3 properties: <code>xtzBalance</code>, <code>tzbtcBalance</code>, and <code>sirsBalance</code> or <code>null</code> if any error occurs.</p>
<ol start="3">
<li>Inisde the <code>try</code> add the following:</li>
</ol>
<pre><code class="language-TS">const xtzBalance = await Tezos.tz.getBalance(userAddress);
if (!xtzBalance) throw &quot;Unable to fetch XTZ balance&quot;;
</code></pre>
<p>The instance of the <code>TezosToolkit</code> includes a property called tz that allows different Tezos-specific actions, one of them is about fetching the balance of an account by its address through the <code>getBalance()</code> method that takes the address of the account as a parameter.</p>
<p>Next, you check for the existence of a balance and you reject the promise if it doesn’t exist. If it does, the balance will be available as a <a href="https://mikemcl.github.io/bignumber.js/">BigNumber</a>.</p>
<div id="admonition-note-1" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.2.html#admonition-note-1"></a></p>
</div>
<div>
<p>Taquito returns numeric values from the blockchain as BigNumber, because some values could be very big numbers and JavaScript is notorious for being bad at handling large numbers</p>
</div>
</div>
<ol start="4">
<li>Once the XTZ balance has been fetched, we can continue and fetch the balances using the following:</li>
</ol>
<pre><code class="language-TS">import { tzbtcAddress, sirsAddress } from &quot;./config&quot;;

// previous code for the function
const res = await fetch(
  `https://api.tzkt.io/v1/tokens/balances?account=${userAddress}&amp;token.contract.in=${tzbtcAddress},${sirsAddress}`
);
if (res.status === 200) {
  const data = await res.json();
  if (Array.isArray(data) &amp;&amp; data.length === 2) {
    const tzbtcBalance = +data[0].balance;
    const sirsBalance = +data[1].balance;
    if (!isNaN(tzbtcBalance) &amp;&amp; !isNaN(sirsBalance)) {
      return {
        xtzBalance: xtzBalance.toNumber(),
        tzbtcBalance,
        sirsBalance
      };
    } else {
      return null;
    }
  }
} else {
  throw &quot;Unable to fetch tzBTC and SIRS balances&quot;;
}
</code></pre>
<div id="admonition-info" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.2.html#admonition-info"></a></p>
</div>
<div>
<p>This <a href="https://api.tzkt.io/#operation/Tokens_GetTokenBalances">link</a> to get more details about how to <code>fetch</code> token balances with the TzKT API. It’s a simple fetch with a URL that is built dynamically to include the user’s address and the addresses of the contracts for tzBTC and SIRS.</p>
</div>
</div>
When the promise resolves with a `200 OK` code, this means that the data has been received. You parse it into JSON with the `.json()` method on the response and we check that the data has the expected shape, i.e. an array with 2 elements in it.
<p>The first element is the tzBTC balance and the second one is the SIRS balance. You store them in their own variables that you cast to numbers before verifying that they were cast properly with <code>isNaN</code>. If everything goes well, the 3 balances are returned and if anything goes wrong along the way, the function returns <code>null</code>.</p>
<ol start="5">
<li>After fetching the balances in any component of our application, this data is stored to update the state in the <code>wallet.svelte</code>:</li>
</ol>
<pre><code class="language-TS">const res = await fetchBalances($store.Tezos, userAddress);
if (res) {
  store.updateUserBalance(&quot;XTZ&quot;, res.xtzBalance);
  store.updateUserBalance(&quot;tzBTC&quot;, res.tzbtcBalance);
  store.updateUserBalance(&quot;SIRS&quot;, res.sirsBalance);
} else {
  store.updateUserBalance(&quot;XTZ&quot;, null);
  store.updateUserBalance(&quot;tzBTC&quot;, null);
  store.updateUserBalance(&quot;SIRS&quot;, null);
}
</code></pre>
<div id="admonition-default-1" class="admonition success">
<div>
<p>Now you can fetch a user’s balances in XTZ, tzBTC, and SIRS!</p>
</div>
</div>
<p><a href="tutorials//tutorials/page-1.1.html">← Previous Page</a></p>
<p><a href="tutorials//tutorials/page-1.3.html">Next Page →</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swapping-tokens"><a class="header" href="#swapping-tokens">Swapping tokens</a></h1>
<h3 id="designing-the-ui"><a class="header" href="#designing-the-ui">Designing the UI</a></h3>
<p>Regarding swapping XTZ and tzBTC, we aim to UI to look something like this:</p>
<p><img src="tutorials/images/image-1.png" alt="image-1" /></p>
<p>There are 2 text inputs, the one on the left is editable and will let the user input the amount of XTZ or tzBTC they want to exchange and the one on the right will be disabled and will display the corresponding amount they’ll get in the other token. The button in the middle with the 2 arrows will allow the user to switch the input between XTZ and tzBTC.</p>
<p>Going into the details of how the text inputs are implemented would go beyond the scope of this tutorial, but you can have a look at it in the <code>UserInput.svelte</code> file.</p>
<h3 id="handling-user-input"><a class="header" href="#handling-user-input">Handling user input</a></h3>
<p>Each input with its token icon and max field is the same component, the parent component tracks the position of each to update their UI accordingly. Internally, each input component keeps track of the user’s input and the available balance to display error messages if the balance is too low. Each update in the input is dispatched to the parent component to adjust the general UI.</p>
<ol>
<li>Make sure the <code>SwapView.svelte</code> file looks something like this:</li>
</ol>
<pre><code class="language-TS">&lt;script lang=&quot;ts&quot;&gt;
  ... your TypeScript code
&lt;/script&gt;

&lt;style lang=&quot;scss&quot;&gt;
   ... your SASS code
&lt;/style&gt;

... your HTML code
</code></pre>
<p>Import the following libraries and components inside the <code>&lt;script&gt;</code> tag:</p>
<pre><code class="language-TS">  import { onMount } from &quot;svelte&quot;;
  import UserInput from &quot;./UserInput.svelte&quot;;
  import { type token, TxStatus } from &quot;../types&quot;;
  import {
    xtzToTokenTokenOutput,
    tokenToXtzXtzOutput,
    calcSlippageValue
  } from &quot;../lbUtils&quot;;
  import store from &quot;../store&quot;;
  import { displayTokenAmount, fetchBalances, calcDeadline } from &quot;../utils&quot;;
  import { dexAddress, tzbtcAddress, XTZ, tzBTC } from &quot;../config&quot;;
</code></pre>
<p>Below this, also declare these variables:</p>
<pre><code class="language-TS">  let tokenFrom: token = &quot;XTZ&quot;;
  let tokenTo: token = &quot;tzBTC&quot;;
  let inputFrom = &quot;&quot;;
  let inputTo = &quot;&quot;;
  let minimumOutput = 0;
  let xtzToTzbtc = 0;
  let tzbtcToXtz = 0;
  let slippage: &quot;0.1&quot; | &quot;0.5&quot; | &quot;1&quot; = &quot;0.1&quot;;
  let insufficientBalance = false;
  let resetInputs = false;
  let swapStatus = TxStatus.NoTransaction;
</code></pre>
<p>Also don’t forget to include the <code>onMount</code> function we created previous and the end of the <code>&lt;script&gt;</code>.</p>
<ol start="2">
<li>Every time an update is sent to the parent component (SwapView.svelte), the data provided with the update is passed to the saveInput. This is achieved by the follow in the <code>SwapView.svelte</code> file:</li>
</ol>
<pre><code class="language-TS">const saveInput = ev =&gt; {
  const { token, val, insufficientBalance: insufBlnc } = ev.detail;
  insufficientBalance = insufBlnc;
  if (token === tokenFrom &amp;&amp; val &gt; 0) {
    inputFrom = val.toString();
    inputTo = &quot;&quot;;
    if (tokenFrom === &quot;XTZ&quot;) {
      // calculates tzBTC amount
      let tzbtcAmount = xtzToTokenTokenOutput({
        xtzIn: val * 10 ** XTZ.decimals,
        xtzPool: $store.dexInfo.xtzPool,
        tokenPool: $store.dexInfo.tokenPool
      });
      if (tzbtcAmount) {
        inputTo = tzbtcAmount.dividedBy(10 ** tzBTC.decimals).toPrecision(6);
      }
      // calculates minimum output
      minimumOutput = calcSlippageValue(&quot;tzBTC&quot;, +inputTo, +slippage);
    } else if (tokenFrom === &quot;tzBTC&quot;) {
      // calculates XTZ amount
      let xtzAmount = tokenToXtzXtzOutput({
        tokenIn: val * 10 ** tzBTC.decimals,
        xtzPool: $store.dexInfo.xtzPool,
        tokenPool: $store.dexInfo.tokenPool
      });
      if (xtzAmount) {
        inputTo = xtzAmount.dividedBy(10 ** XTZ.decimals).toPrecision(8);
      }
      // calculates minimum output
      minimumOutput = calcSlippageValue(&quot;XTZ&quot;, +inputTo, +slippage);
    }
  } else {
    inputFrom = &quot;&quot;;
    inputTo = &quot;&quot;;
  }
};
</code></pre>
<div id="admonition-what-are-these" class="admonition tip">
<div class="admonition-title">
<p>What are these?</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.3.html#admonition-what-are-these"></a></p>
</div>
<div>
<ul>
<li>The values necessary for the calculations of the token amounts are destructured from the <code>ev.detail</code> object.</li>
<li>The function verifies that the values are received from the token that is currently active (the one on the left).</li>
<li>If that token is XTZ, the amount in tzBTC is calculated via the <code>xtzToTokenTokenOutput</code> function (more on that below).</li>
<li>If that token is tzBTC, the amount in XTZ is calculated via the <code>tokenToXtzXtzOutput</code> function (more on that below).</li>
<li>The minimum amount to be expected according to the slippage set by the user is calculated by the <code>calcSlippage</code> function.</li>
</ul>
</div>
</div>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.3.html#admonition-note"></a></p>
</div>
<div>
<p>The “slippage” refers to the percentage that the user accepts to lose during the trade, a loss of tokens can happen according to the state of the liquidity pools. For example, if 100 tokens A can be swapped for 100 tokens B with a slippage of 1%, it means that you will receive between 99 and 100 tokens B.</p>
</div>
</div>
<h3 id="exchanging-xtz-for-tzbtc-for-xtz"><a class="header" href="#exchanging-xtz-for-tzbtc-for-xtz">Exchanging XTZ for tzBTC for XTZ</a></h3>
<p>Both <code>xtzToTokenTokenOutput</code> and <code>tokenToXtzXtzOutput</code> are an aadaptation fro this <a href="https://github.com/kukai-wallet/kukai-dex-calculations">repository</a> which will allow us to calculate how many tzBTC a user will get according to the XTZ amount they input and vice-versa.</p>
<ol>
<li>This is achieved using this function:</li>
</ol>
<pre><code class="language-TS">export const xtzToTokenTokenOutput = (p: {
  xtzIn: BigNumber | number;
  xtzPool: BigNumber | number;
  tokenPool: BigNumber | number;
}): BigNumber | null =&gt; {
  let { xtzIn, xtzPool: _xtzPool, tokenPool } = p;
  let xtzPool = creditSubsidy(_xtzPool);
  let xtzIn_ = new BigNumber(0);
  let xtzPool_ = new BigNumber(0);
  let tokenPool_ = new BigNumber(0);
  try {
    xtzIn_ = new BigNumber(xtzIn);
    xtzPool_ = new BigNumber(xtzPool);
    tokenPool_ = new BigNumber(tokenPool);
  } catch (err) {
    return null;
  }
  if (
    xtzIn_.isGreaterThan(0) &amp;&amp;
    xtzPool_.isGreaterThan(0) &amp;&amp;
    tokenPool_.isGreaterThan(0)
  ) {
    const numerator = xtzIn_.times(tokenPool_).times(new BigNumber(998001));
    const denominator = xtzPool_
      .times(new BigNumber(1000000))
      .plus(xtzIn_.times(new BigNumber(998001)));
    return numerator.dividedBy(denominator);
  } else {
    return null;
  }
};
</code></pre>
<p>The <code>xtzToTokenTokenOutput</code> function requires 3 values to calculate an output in tzBtc from an input in XTZ: the said amount in XTZ (<code>xtzIn</code>), the state of the XTZ pool in the contract (<code>xtzPool</code>) and the state of the SIRS pool (<code>tokenPool</code>). Most of the modifications made to the original functions apply to the use of BigNumber in order to make it work more smoothly with Taquito. The function then returns the corresponding amount in tzBTC or <code>null</code> if an error occurs.</p>
<ol start="2">
<li>The same for the <code>tokenToXtzXtzOutput</code>:</li>
</ol>
<pre><code class="language-TS">export const tokenToXtzXtzOutput = (p: {
  tokenIn: BigNumber | number;
  xtzPool: BigNumber | number;
  tokenPool: BigNumber | number;
}): BigNumber | null =&gt; {
  const { tokenIn, xtzPool: _xtzPool, tokenPool } = p;
  let xtzPool = creditSubsidy(_xtzPool);
  let tokenIn_ = new BigNumber(0);
  let xtzPool_ = new BigNumber(0);
  let tokenPool_ = new BigNumber(0);
  try {
    tokenIn_ = new BigNumber(tokenIn);
    xtzPool_ = new BigNumber(xtzPool);
    tokenPool_ = new BigNumber(tokenPool);
  } catch (err) {
    return null;
  }
  if (
    tokenIn_.isGreaterThan(0) &amp;&amp;
    xtzPool_.isGreaterThan(0) &amp;&amp;
    tokenPool_.isGreaterThan(0)
  ) {
    let numerator = new BigNumber(tokenIn)
      .times(new BigNumber(xtzPool))
      .times(new BigNumber(998001));
    let denominator = new BigNumber(tokenPool)
      .times(new BigNumber(1000000))
      .plus(new BigNumber(tokenIn).times(new BigNumber(999000)));
    return numerator.dividedBy(denominator);
  } else {
    return null;
  }
};
</code></pre>
<p>After the corresponding amount of XTZ or tzBTC is calculated according to the inputs of the user, the UI unlocks and is ready for a swap.</p>
<h3 id="creating-a-swap-transaction"><a class="header" href="#creating-a-swap-transaction">Creating a swap transaction:</a></h3>
<p>Swapping the tokens is pretty intensive as they are multiple moving parts that must play in unison. </p>
<p>Describing step by step what happens after the user clicks on the Swap button, this function:</p>
<pre><code class="language-TS">const swap = async () =&gt; {
  try {
    if (isNaN(+inputFrom) || isNaN(+inputTo)) {
      return;
    }
  
  ...
  } catch (error) {
    console.log(error);
    swapStatus = TxStatus.Error;
    store.updateToast(true, &quot;An error has occurred&quot;);
  }
};
</code></pre>
<p>The swap function is triggered when the user clicks the Swap button. The first thing to do is to check if there is a valid value for <code>inputFrom</code>, i.e. the token that the user wants to exchange (XTZ or tzBTC), and a valid value for inputTo, i.e. the token that the user will receive. There is no point in going further if those two values are not set properly.</p>
<p>Next, you update the UI in order to show the user that the transaction is getting ready:</p>
<pre><code class="language-TS">enum TxStatus {
  NoTransaction,
  Loading,
  Success,
  Error
}

swapStatus = TxStatus.Loading;
store.updateToast(true, &quot;Waiting to confirm the swap...&quot;);
const lbContract = await $store.Tezos.wallet.at(dexAddress);
const deadline = calcDeadline();
</code></pre>
<p>This creates an enum to represent the status of the transaction (available in the <code>type.ts</code> file) and you update the <code>swapStatus</code> variable responsible for updating the UI and blocking the inputs. The store is also updated with the updateToast() method to get a simple toast to show up in the interface.</p>
<p>Afterwards, it creates the <code>ContractAbstraction</code> from Taquito in order to interact with the DEX and you also calculate the deadline.</p>
<div id="admonition-note-1" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.3.html#admonition-note-1"></a></p>
</div>
<div>
<p>The Liquidity Baking contract expects you to pass a deadline for the swap, the transaction will be rejected if the deadline is expired.</p>
</div>
</div>
<h3 id="swapping-tzbtc-for-xtz"><a class="header" href="#swapping-tzbtc-for-xtz">Swapping tzBTC for XTZ</a></h3>
<p>There are 2 use ases where you’d like the user to select either XTZ or tzBTC as the token to swap. </p>
<ol>
<li>Firstly looking at tzBTC to XTZ, we can use the following function:</li>
</ol>
<pre><code class="language-TS">if (tokenFrom === &quot;tzBTC&quot;) {
  const tzBtcContract = await $store.Tezos.wallet.at(tzbtcAddress);
  const tokensSold = Math.floor(+inputFrom * 10 ** tzBTC.decimals);
  let batch = $store.Tezos.wallet
    .batch()
    .withContractCall(tzBtcContract.methods.approve(dexAddress, 0))
    .withContractCall(
    tzBtcContract.methods.approve(dexAddress, tokensSold)
    )
    .withContractCall(
    lbContract.methods.tokenToXtz(
        $store.userAddress,
        tokensSold,
        minimumOutput,
        deadline
      )
    )
    .withContractCall(tzBtcContract.methods.approve(dexAddress, 0));
  const batchOp = await batch.send();
  await batchOp.confirmation();
}
</code></pre>
<p>The major difference between swapping XTZ to tzBTC and swapping tzBTC to XTZ is that the latter requires 3 additional operations: </p>
<ul>
<li>One to set the current permission for the LB DEX (if any) to zero.</li>
<li>One to register the LB DEX as an operator within the tzBTC contract with the amount of tokens that it is allowed to spend on behalf of the user.</li>
<li>One to set this amount back to zero and avoid later uses of the given permission.</li>
</ul>
<p>How this works is that:</p>
<ul>
<li>
<p>You call the <code>batch()</code> method present on the <code>wallet</code> or <code>contract</code> property of the instance of the <code>TezosToolkit</code>.</p>
</li>
<li>
<p>This returns a batch instance with different methods that you can use to create transactions, in our example, <code>withContractCall()</code> is a method that will add a new contract call to the batch of operations.</p>
</li>
<li>
<p>As a parameter for <code>withContractCall()</code>, you pass the contract call as if you would call it on its own, by using the name of the entrypoint on the methods property of the <code>ContractAbstraction</code>.</p>
</li>
<li>
<p>Therefore you batch 1 operation to set the permission of the LB DEX within the tzBTC contract to zero, 1 operation to approve the amount required by the swap, 1 operation to confirm the swap within the LB DEX contract, and 1 operation to set the permission of the LB DEX back to zero.</p>
</li>
<li>
<p>On the returned batch, you call the <code>.send()</code> method to forge the transaction, sign it and send it to the Tezos mempool, which returns an operation.</p>
</li>
<li>
<p>You can <code>await</code> the confirmation of the transaction by calling <code>.confirmation()</code> on the operation returned in the step above.</p>
</li>
</ul>
<div id="admonition-note-2" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.3.html#admonition-note-2"></a></p>
</div>
<div>
<p>The penultimate transaction: the tokenToXtz entrypoint of the LB contract requires 4 parameters.</p>
</div>
</div>
<p>After the transaction is sent by calling the <code>.send()</code> method, it calls <code>.confirmation()</code> on the operation object to wait for one confirmation (which is the default if you don’t pass a parameter to the method).</p>
<h3 id="swapping-xtz-to-tzbtc"><a class="header" href="#swapping-xtz-to-tzbtc">Swapping XTZ to tzBTC</a></h3>
<p>The <code>xtzToToken</code> entrypoint takes 3 parameters:</p>
<ul>
<li>The address of the account that will receive the tzBTC tokens</li>
<li>The expected amount of tzBTC to be received</li>
<li>The deadline</li>
</ul>
<p>Therefore using the following code will allow for it easily swapp the currencies:</p>
<pre><code class="language-TS">const op = await lbContract.methods
  .xtzToToken($store.userAddress, minimumOutput, deadline)
  .send({ amount: +inputFrom });
await op.confirmation();
</code></pre>
<p>In addition to that, you have to attach the right amount of XTZ to the transaction. This can be achieved very easily with Taquito.</p>
<div id="admonition-note-3" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.3.html#admonition-note-3"></a></p>
</div>
<div>
<p>The <code>.send()</code> method that you call on the output of the entrypoint call? If you didn’t know, you can pass parameters to this method, one of the most important ones is an <code>amount</code> of XTZ to send along with the transaction. Just pass an object with an amount property and a value of the amount of tez you want to attach, and that’s it!</p>
</div>
</div>
<p>Just like any other transaction, you get an operation object and call <code>.confirmation()</code> on it to wait for the operation to be included in a new block.</p>
<h3 id="updating-the-ui"><a class="header" href="#updating-the-ui">Updating the UI</a></h3>
<p>Giving the user any indiation of a sucessful or not transaction is crucial feedback. </p>
<p>If the swap succeeded, it will fetch the user’s new balances and provide visual feedback:</p>
<pre><code class="language-TS">const res = await fetchBalances($store.Tezos, $store.userAddress);
if (res) {
  store.updateUserBalance(&quot;XTZ&quot;, res.xtzBalance);
  store.updateUserBalance(&quot;tzBTC&quot;, res.tzbtcBalance);
  store.updateUserBalance(&quot;SIRS&quot;, res.sirsBalance);
} else {
  store.updateUserBalance(&quot;XTZ&quot;, null);
  store.updateUserBalance(&quot;tzBTC&quot;, null);
  store.updateUserBalance(&quot;SIRS&quot;, null);
}
// visual feedback
store.updateToast(true, &quot;Swap successful!&quot;);
</code></pre>
<p>If the sway failed, it will redirect to the <code>catch</code> branch where you also have to provide visual feedback and update the UI:</p>
<pre><code class="language-TS">swapStatus = TxStatus.Error;
store.updateToast(true, &quot;An error has occurred&quot;);
</code></pre>
<p>Setting swapStatus to TxStatus.Error will remove the loading interface you set during the swap before you display a toast to indicate that the transaction failed.</p>
<p>Lastly, the <code>finally</code> branch will reset the UI after period of time. In this case 3 seconds:</p>
<pre><code class="language-TS">finally {
  setTimeout(() =&gt; {
    swapStatus = TxStatus.NoTransaction;
    store.showToast(false);
  }, 3000);
}
</code></pre>
<div id="admonition-design-considerations" class="admonition tip">
<div class="admonition-title">
<p>Design considerations&gt;</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.3.html#admonition-design-considerations"></a></p>
</div>
<div>
<ul>
<li>Structure your code into distinct steps, such as updating the UI, forging the transaction, emitting the transaction, and updating the UI again.</li>
<li>Provide visual feedback to users, such as a spinner or loading animation, to indicate that the app is processing their request.</li>
<li>Disable the UI while the transaction is in progress to prevent confusion and unexpected behavior. Users should not be able to initiate multiple transactions at once.</li>
<li>Reset the UI to its original state once the transaction is complete, to avoid confusing the user and make sure the interface is consistent.</li>
</ul>
</div>
</div>
<p><a href="tutorials//tutorials/page-1.2.html">← Previous Page</a></p>
<p><a href="tutorials//tutorials/page-1.4.html">Next Page →</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-and-removing-liquidity"><a class="header" href="#adding-and-removing-liquidity">Adding and removing liquidity</a></h1>
<p>The most complex part of this tutorial about adding liquidity to the Liquidity Baking contract is to get the amounts of tokens right.</p>
<p>The LB DEX gives you the ability to provide a pair of tokens (only 2 choices here, XTZ and tzBTC) as liquidity to enable the swapping feature. In exchange, you get SIRS tokens to represent your investment. These tokens increase in value over time, so if you wait long enough, you can make a profit when you remove your liquidity, which will be explained down below.</p>
<p>We aiming for the UI to look similar to the swapping interface, with a few difference:</p>
<p><img src="tutorials/images/image-2.png.webp" alt="image-1" /></p>
<p>Like before, we have 2 input fields, but this time, there is no middle button to switch between the 2 tokens and both inputs are editable.</p>
<p>When inputting a number in one of the fields, the dapp must calculate the corresponding amount of the other token, as well as the expected amount in SIRS that will be received.</p>
<h3 id="converting-the-input"><a class="header" href="#converting-the-input">Converting the input</a></h3>
<p>When the user is going to input a number in one of the fields, the input will dispatch a new event to the interface component with the name of the token involved and the amount that was input.</p>
<ol>
<li>Make sure the <code>AddLiquidity.svelte</code> file looks something like this:</li>
</ol>
<pre><code class="language-TS">&lt;script lang=&quot;ts&quot;&gt;
  ... your TypeScript code
&lt;/script&gt;

&lt;style lang=&quot;scss&quot;&gt;
   ... your SASS code
&lt;/style&gt;

... your HTML code
</code></pre>
<p>Import the following libraries and components inside the <code>&lt;script&gt;</code> tag:</p>
<pre><code class="language-TS">  import { OpKind } from &quot;@taquito/taquito&quot;;
  import store from &quot;../store&quot;;
  import UserInput from &quot;./UserInput.svelte&quot;;
  import { type token, TxStatus } from &quot;../types&quot;;
  import {
    addLiquidityTokenIn,
    tokenToXtzXtzOutput,
    addLiquidityLiquidityCreated
  } from &quot;../lbUtils&quot;;
  import { dexAddress, tzbtcAddress, XTZ, tzBTC } from &quot;../config&quot;;
  import { calcDeadline, fetchBalances } from &quot;../utils&quot;;
</code></pre>
<p>Below this, also declare these variables:</p>
<pre><code class="language-TS">  let inputXtz = &quot;&quot;;
  let inputTzbtc = &quot;&quot;;
  let sirsOutput = 0;
  let addLiquidityStatus = TxStatus.NoTransaction;
  let resetXtzInput = false;
  let resetTzbtcInput = false;

  let swapStatus = TxStatus.NoTransaction;
</code></pre>
<p>Also don’t forget to include the <code>onMount</code> function we created previous and the end of the <code>&lt;script&gt;</code>.</p>
<ol start="2">
<li>This data will be read by the <code>saveInput</code> function. By adding the following function:</li>
</ol>
<pre><code class="language-TS">const saveInput = ev =&gt; {
    const { token, val }: { token: token; val: number | null } = ev.detail;
    ...
}
</code></pre>
<ol start="3">
<li>Then, we will introduce a condition based on the token because the calculations will be different to convert an amount of XTZ into tzBTC and vice-versa. </li>
</ol>
<p>Starting with XTZ, inside the <code>saveInput</code> function:</p>
<pre><code class="language-TS">if (token === &quot;XTZ&quot; &amp;&amp; val &amp;&amp; val &gt; 0) {
  inputXtz = val.toString();
  let tzbtcAmount = addLiquidityTokenIn({
    xtzIn: val * 10 ** 6,
    xtzPool: $store.dexInfo.xtzPool,
    tokenPool: $store.dexInfo.tokenPool
  });
  if (tzbtcAmount) {
    inputTzbtc = tzbtcAmount.dividedBy(10 ** 8).toPrecision(6);
  } else {
    inputTzbtc = &quot;&quot;;
  }
  ...
}
</code></pre>
<p>The condition also includes a check for the value, as there is no need to process it if the value is <code>nul</code>l or <code>0</code>.</p>
<ol start="4">
<li>The value is cast to a string and stored in the <code>inputXtz</code> variable to be used later. The corresponding amount of tzBTC is calculated with the <code>addLiquidityTokenIn</code> function.</li>
</ol>
<p>For calculating the different token amounts for the LB DEX, we’ll following under the <code>saveInput</code> function:</p>
<pre><code class="language-TS">const addLiquidityTokenIn = (p: {
  xtzIn: BigNumber | number;
  xtzPool: BigNumber | number;
  tokenPool: BigNumber | number;
}): BigNumber | null =&gt; {
  const { xtzIn, xtzPool, tokenPool } = p;
  let xtzIn_ = new BigNumber(0);
  let xtzPool_ = new BigNumber(0);
  let tokenPool_ = new BigNumber(0);
  try {
    xtzIn_ = new BigNumber(xtzIn);
    xtzPool_ = creditSubsidy(xtzPool);
    tokenPool_ = new BigNumber(tokenPool);
  } catch (err) {
    return null;
  }
  if (
    xtzIn_.isGreaterThan(0) &amp;&amp;
    xtzPool_.isGreaterThan(0) &amp;&amp;
    tokenPool_.isGreaterThan(0)
  ) {
    return ceilingDiv(xtzIn_.times(tokenPool_), xtzPool_);
  } else {
    return null;
  }
};
</code></pre>
<p>This checks the output of addLiquidityTokenIn and we update the inputTzbtc variable.</p>
<ol start="5">
<li>If the user inputs an amount in tzBTC, the steps will be very similar to calculate the corresponding amount in XTZ. Back inside the <code>saveInput</code> function add:</li>
</ol>
<pre><code class="language-TS">else if (token === &quot;tzBTC&quot; &amp;&amp; val &amp;&amp; val &gt; 0) {
  inputTzbtc = val.toString();
  let xtzAmount = tokenToXtzXtzOutput({
    tokenIn: val * 10 ** 8,
    xtzPool: $store.dexInfo.xtzPool,
    tokenPool: $store.dexInfo.tokenPool
  });
  if (xtzAmount) {
    inputXtz = xtzAmount.dividedBy(10 ** 6).toPrecision(8);
    ...
  } else {
    inputXtz = &quot;&quot;;
  }
}
</code></pre>
<ol start="6">
<li>We also need to check that the provided value is correct, after what we use the <code>tokenToXtzXtzOutput</code> function to get the corresponding amount of XTZ to create a valid pair and provide liquidity.</li>
</ol>
<p>We’ll use the following function called <code>tokenToXtzOutput</code>:</p>
<pre><code class="language-TS">const tokenToXtzXtzOutput = (p: {
  tokenIn: BigNumber | number;
  xtzPool: BigNumber | number;
  tokenPool: BigNumber | number;
}): BigNumber | null =&gt; {
  const { tokenIn, xtzPool: _xtzPool, tokenPool } = p;
  let xtzPool = creditSubsidy(_xtzPool);
  let tokenIn_ = new BigNumber(0);
  let xtzPool_ = new BigNumber(0);
  let tokenPool_ = new BigNumber(0);
  try {
    tokenIn_ = new BigNumber(tokenIn);
    xtzPool_ = new BigNumber(xtzPool);
    tokenPool_ = new BigNumber(tokenPool);
  } catch (err) {
    return null;
  }
  if (
    tokenIn_.isGreaterThan(0) &amp;&amp;
    xtzPool_.isGreaterThan(0) &amp;&amp;
    tokenPool_.isGreaterThan(0)
  ) {
    let numerator = new BigNumber(tokenIn)
      .times(new BigNumber(xtzPool))
      .times(new BigNumber(998001));
    let denominator = new BigNumber(tokenPool)
      .times(new BigNumber(1000000))
      .plus(new BigNumber(tokenIn).times(new BigNumber(999000)));
    return numerator.dividedBy(denominator);
  } else {
    return null;
  }
};
</code></pre>
<p>Once this is calculated, we store the result in the <code>inputXtz</code> variable for later use.</p>
<h3 id="calculating-the-expected-amount-of-sirs"><a class="header" href="#calculating-the-expected-amount-of-sirs">Calculating the expected amount of SIRS</a></h3>
<p>Now, we have to calculate the corresponding amount of SIRS that will be created if inputXtz and inputTzbtc are provided as parameters to add liquidity.</p>
<ol>
<li>The <code>addLiquidityLiquidityCreated</code> function does carries this out for us. Use the following code inside the <code>lbUtils.ts</code>:</li>
</ol>
<pre><code class="language-TS">const addLiquidityLiquidityCreated = (p: {
  xtzIn: BigNumber | number;
  xtzPool: BigNumber | number;
  totalLiquidity: BigNumber | number;
}): BigNumber | null =&gt; {
  const { xtzIn, xtzPool, totalLiquidity } = p;
  let xtzIn_ = new BigNumber(0);
  let xtzPool_ = new BigNumber(0);
  let totalLiquidity_ = new BigNumber(0);
  try {
    xtzIn_ = new BigNumber(xtzIn);
    xtzPool_ = new BigNumber(xtzPool);
    totalLiquidity_ = new BigNumber(totalLiquidity);
  } catch (err) {
    return null;
  }
  xtzPool_ = creditSubsidy(xtzPool_);

if (xtzIn_.isGreaterThan(0) &amp;&amp; xtzPool_.isGreaterThan(0)) {
  if (totalLiquidity_.isEqualTo(0)) {
    return new BigNumber(xtzIn)
    .times(new BigNumber(totalLiquidity))
    .dividedBy(new BigNumber(xtzPool));
  } else if (totalLiquidity_.isGreaterThan(0)) {
    return new BigNumber(xtzIn)
    .times(new BigNumber(totalLiquidity))
    .dividedBy(new BigNumber(xtzPool));
  }
    return null;
  } else {
    return null;
  }
};
</code></pre>
<div id="admonition-what-are-these" class="admonition tip">
<div class="admonition-title">
<p>What are these?</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.4.html#admonition-what-are-these"></a></p>
</div>
<div>
<p>This function looks at 3 parameters:</p>
<ul>
<li>The amount of XTZ you want to add as liquidity</li>
<li>The current state of the XTZ pool</li>
<li>The total amount of liquidity available in the contract (i.e. the SIRS tokens)</li>
</ul>
</div>
</div>
<p>It will output the amount of SIRS created after the transaction. This amount is stored in the <code>sirsOutput</code> variable to be displayed in the interface.</p>
<h3 id="sending-the-tokens"><a class="header" href="#sending-the-tokens">Sending the tokens</a></h3>
<p>After we calculated all the values we need to add liquidity to the Liquidity Baking contract.</p>
<ol>
<li>Back in the <code>AddLiquidityView.svelte</code> file, add this new function:</li>
</ol>
<pre><code class="language-TS">const addLiquidity = async () =&gt; {
  try {
    if (inputXtz &amp;&amp; inputTzbtc &amp;&amp; sirsOutput) {
      addLiquidityStatus = TxStatus.Loading;
      store.updateToast(
        true,
        &quot;Adding liquidity, waiting for confirmation...&quot;
      );
      const tzbtcForLiquidity = Math.floor(
        +inputTzbtc * 10 ** tzBTC.decimals
      );
      const lbContract = await $store.Tezos.wallet.at(dexAddress);
      const tzBtcContract = await $store.Tezos.wallet.at(tzbtcAddress);
    ...
}
</code></pre>
<p>We need check that the 3 values we need, the amounts of XTZ, tzBTC, and SIRS are available. If it is the case, we update the UI by switching the <code>addLiquidityStatus</code> variable to <code>TxStatus.Loading</code> and by displaying a simple toast with a message.</p>
<p>After that, we convert the amount of tzBTC we got into its “real” value, i.e. the value without decimal points as stored in its contract.</p>
<p>Then, we create the <code>ContractAbstraction</code> for the LB DEX and the <code>ContractAbstraction</code> for the tzBTC contract, as we will interact with both.</p>
<div id="admonition-info" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.4.html#admonition-info"></a></p>
</div>
<div>
<p>Every time your users want to use tzBTC with the LB DEX, the amount of tokens that will be used needs to be approved at the tzBTC contract level, which requires 3 different operations.</p>
</div>
</div>
Now we need to create a batched transaction, howver we'll do it differently to the previous section of this tutorial for variation. Here's an example of how this can be carried out:
<pre><code class="language-TS">const batch = $store.Tezos.wallet.batch([
  {
    kind: OpKind.TRANSACTION,
    ...tzBtcContract.methods.approve(dexAddress, 0).toTransferParams()
  }, // is the transaction required to set the amount of approved tzBTC for the LB DEX to zero.
  {
    kind: OpKind.TRANSACTION,
    ...tzBtcContract.methods
    .approve(dexAddress, tzbtcForLiquidity)
    .toTransferParams()
  }, // sets the amount of approved tzBTC for the LB DEX contract.
  {
    kind: OpKind.TRANSACTION,
    ...lbContract.methodsObject
    .addLiquidity({
      owner: $store.userAddress,
      minLqtMinted: sirsOutput,
      maxTokensDeposited: tzbtcForLiquidity,
      deadline: calcDeadline()
    })
    .toTransferParams(),
    amount: +inputXtz
  }, // sets the amount of approved tzBTC for the LB DEX contract, with 4 paarameters
  {
    kind: OpKind.TRANSACTION,
    ...tzBtcContract.methods.approve(dexAddress, 0).toTransferParams()
  } // resets the allowed amount of tzBTC to be used by the LB DEX to zero
]);

const batchOp = await batch.send();
await batchOp.confirmation();
</code></pre>
<p>In the previous chapter, the batched transaction was created using the <code>withContractCall</code> method available on the <code>batch</code>method. Here, we will actually pass a parameter to the <code>batch()</code> method, an array containing multiple objects that each represent an operation.</p>
<p>Like any other transaction forged through Taquito, you call <code>.send()</code> and <code>.confirmation()</code> on the operation object to wait for one confirmation.</p>
<p>Once the transaction is confirmed, you clear the UI before fetching the new balances of XTZ, tzBTC, and SIRS.</p>
<p>To update the UI to provide visual feedback, we can add the following to the end of funcction that is fetching the user’s XTZ, tzBTC and SIRS balances:</p>
<pre><code class="language-TS">addLiquidityStatus = TxStatus.Error;
store.updateToast(true, &quot;An error has occurred&quot;);
</code></pre>
<p>Also using the 3 seconds timeout would be useful:</p>
<pre><code class="language-TS">setTimeout(() =&gt; {
  addLiquidityStatus = TxStatus.NoTransaction;
  store.showToast(false);
}, 3000);
</code></pre>
<div id="admonition-default" class="admonition success">
<div>
<p>The user now has the ability to add liquidity to the Liquidity Baking DEX and invest their XTZ and tzBTC.</p>
</div>
</div>
<h3 id="removing-liquidity"><a class="header" href="#removing-liquidity">Removing liquidity</a></h3>
<p>Removing liquidity from the Liquidity Baking contract is arguably the easiest of all the tasks accomplished by our interface. The interface only needs one input to receive the amount of SIRS that the user wants to unwrap to get XTZ and tzBTC.</p>
<p>The dapp will then calculate the corresponding amount of XTZ and tzBTC expected to be received for the amount of SIRS in the input field.</p>
<ol>
<li>Inside the <code>lbUtils.ts</code> file, we can create <code>removeLiquidityXtzTzbtcOut</code> function to calculate these amounts. </li>
</ol>
<p>Using the following will help achieve this:</p>
<pre><code class="language-TS">const outputRes = removeLiquidityXtzTzbtcOut({
  liquidityBurned: val, // the amount of SIRS to burn
  totalLiquidity: $store.dexInfo.lqtTotal.toNumber(), // the total amount of SIRS tokens in the contract
  xtzPool: $store.dexInfo.xtzPool.toNumber(), // the total amount of XTZ tokens in the contract
  tokenPool: $store.dexInfo.tokenPool.toNumber() // the total amount of tzBTC tokens in the contract
});
if (outputRes) {
  const { xtzOut, tzbtcOut } = outputRes;
  xtzOutput = xtzOut
    .decimalPlaces(0, 1)
    .dividedBy(10 ** 6)
    .decimalPlaces(6)
    .toNumber();
  tzbtcOutput = tzbtcOut
    .decimalPlaces(0, 1)
    .dividedBy(10 ** 8)
    .decimalPlaces(8)
    .toNumber();
}
</code></pre>
<p>If the function has been able to calculate the amounts of XTZ and tzBTC, they are returned in an object, otherwise <code>null</code>is returned. After that, those amounts can be displayed in the interface.</p>
<p>Now, we must implement a way to interact with the <code>removeLiquidity</code> entrypoint of the contract. </p>
<ol>
<li>Make sure the <code>RemoveLiquidityView.svelte</code> file looks something like this:</li>
</ol>
<pre><code class="language-TS">&lt;script lang=&quot;ts&quot;&gt;
  ... your TypeScript code
&lt;/script&gt;

&lt;style lang=&quot;scss&quot;&gt;
   ... your SASS code
&lt;/style&gt;

... your HTML code
</code></pre>
<p>Import the following libraries and components inside the <code>&lt;script&gt;</code> tag:</p>
<pre><code class="language-TS">  import store from &quot;../store&quot;;
  import UserInput from &quot;./UserInput.svelte&quot;;
  import { removeLiquidityXtzTzbtcOut } from &quot;../lbUtils&quot;;
  import { TxStatus } from &quot;../types&quot;;
  import { calcDeadline, fetchBalances } from &quot;../utils&quot;;
  import { dexAddress, XTZ, tzBTC } from &quot;../config&quot;;
</code></pre>
<p>Below this, also declare these variables:</p>
<pre><code class="language-TS">  let inputSirs = &quot;&quot;;
  let xtzOutput = 0;
  let tzbtcOutput = 0;
  let resetInput = false;
  let removeLiquidityStatus = TxStatus.NoTransaction;
</code></pre>
<p>Also don’t forget to include the <code>onMount</code> function we created previous and the end of the <code>&lt;script&gt;</code>.</p>
<div id="admonition-info-1" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="tutorials/page-1.4.html#admonition-info-1"></a></p>
</div>
<div>
<p>The file should also have the <code>saveInput</code> function as this will be retaining the data that we’ll be removing.</p>
</div>
</div>
<ol start="2">
<li>First, we create a removeLiquidity function within our TypeScript code that will be triggered when the user clicks on the Remove liquidity button:</li>
</ol>
<pre><code class="language-TS">const removeLiquidity = async () =&gt; {
  try {
  if (inputSirs) {
    removeLiquidityStatus = TxStatus.Loading;
    store.updateToast(
      true,
      &quot;Removing liquidity, waiting for confirmation...&quot;
    );
    const lbContract = await $store.Tezos.wallet.at(dexAddress);
          
  ...
};
</code></pre>
<p>The function starts by checking if there is an amount of SIRS that was input before the remove liquidity action was triggered. If that’s the case, the <code>removeLiquidityStatus</code> is set to <code>loading</code> to update the UI and inform the user that the transaction is getting ready. A toast will also be displayed.</p>
<p>Then <code>ContractAbstraction</code> is created for the LB DEX in order to interact with it from Taquito.</p>
<ol start="3">
<li>Now we can forge the actual transaction by also adding:</li>
</ol>
<pre><code class="language-TS">const op = await lbContract.methodsObject
  .removeLiquidity({
    to: $store.userAddress, //  the account that will receive the XTZ and tzBTC
    lqtBurned: inputSirs, // the amount of SIRS to burn
    minXtzWithdrawn: Math.floor(xtzOutput * 10 ** XTZ.decimals), // the minimum amount of XTZ expected to be received
    minTokensWithdrawn: Math.floor(tzbtcOutput * 10 ** tzBTC.decimals), // the minimum amount of tzBTC expected to be received
    deadline: calcDeadline() //  just as the other entrypoint, a deadline for the transaction must be provided
  })
  .send();
await op.confirmation();
</code></pre>
<p>After the transaction has been emitted, we call .confirmation() on the operation object returned by Taquito.</p>
<ol start="4">
<li>Similar to before, if transaction was successful, we update the UI and reset the token values:</li>
</ol>
<pre><code class="language-TS">removeLiquidityStatus = TxStatus.Success;
inputSirs = &quot;&quot;;
xtzOutput = 0;
tzbtcOutput = 0;
// fetches user's XTZ, tzBTC and SIRS balances
const res = await fetchBalances($store.Tezos, $store.userAddress);
if (res) {
  store.updateUserBalance(&quot;XTZ&quot;, res.xtzBalance);
  store.updateUserBalance(&quot;tzBTC&quot;, res.tzbtcBalance);
  store.updateUserBalance(&quot;SIRS&quot;, res.sirsBalance);
} else {
  store.updateUserBalance(&quot;XTZ&quot;, null);
  store.updateUserBalance(&quot;tzBTC&quot;, null);
  store.updateUserBalance(&quot;SIRS&quot;, null);
}
store.updateToast(true, &quot;Liquidity successfully removed!&quot;);
</code></pre>
<p>If it fails:</p>
<pre><code class="language-TS">removeLiquidityStatus = TxStatus.Error;
store.updateToast(true, &quot;An error has occurred&quot;);
</code></pre>
<div id="admonition-default-1" class="admonition success">
<div>
<p>And that’s it, the users have now the possibility to remove SIRS tokens and get XTZ and tzBTC tokens in exchange!</p>
</div>
</div>
<p><a href="tutorials//tutorials/page-1.3.html">← Previous Page</a></p>
<p><a href="tutorials//tutorials/page-1.5.html">Next Page →</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<div id="admonition-default" class="admonition success">
<div>
<p>You’ve made it until the end of this tutorial.</p>
</div>
</div>
This very simple dapp introduced a lot of different concepts that are fundamental to developing applications on Tezos, but also to understanding how Tezos works in general.
<p>Taquito is an amazing library to develop on Tezos, whether you want to prototype ideas quickly or want to create full-stack decentralized applications. It provides a main library with all you need to read from the Tezos blockchain, interact with smart contracts and use wallets, and several smaller packages for specific usage, for example, reading token metadata or batching operations.</p>
<p>Whether you want to build a front-end app, a back-end or even a desktop app, as long as you are using JavaScript/NodeJS, you will be able to use Taquito!</p>
<p>This tutorial also introduced different tools you may need on your journey to developing dapps on Tezos, The Beacon SDK to interact with wallets, the TzKT API to get more data from the blockchain, etc.</p>
<p>Although this tutorial uses Svelte as its framework of choice, the skills you learned are transferrable to other frameworks as they are based on a lot of the same concepts (the component lifecycles are very similar, etc.) It gives you everything you need to build amazing dapps on Tezos and I can’t wait to see what you will build next!</p>
<div id="admonition-default-1" class="admonition success">
<div>
<p>If you want to learn more about how to create awesome dapps on Tezos, Chekout this video!</p>
</div>
</div>
<iframe width="800" height="400" src="https://www.youtube.com/embed/4_L3U-gzO_U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<p><a href="tutorials//tutorials/page-1.4.html">← Previous Page</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
